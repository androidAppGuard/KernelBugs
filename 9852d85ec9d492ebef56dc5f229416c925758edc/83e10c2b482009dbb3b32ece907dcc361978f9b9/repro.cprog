// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE 

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/usb/ch9.h>

static unsigned long long procid;

static void sleep_ms(uint64_t ms)
{
	usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
	struct timespec ts;
	if (clock_gettime(CLOCK_MONOTONIC, &ts))
	exit(1);
	return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static bool write_file(const char* file, const char* what, ...)
{
	char buf[1024];
	va_list args;
	va_start(args, what);
	vsnprintf(buf, sizeof(buf), what, args);
	va_end(args);
	buf[sizeof(buf) - 1] = 0;
	int len = strlen(buf);
	int fd = open(file, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return false;
	if (write(fd, buf, len) != len) {
		int err = errno;
		close(fd);
		errno = err;
		return false;
	}
	close(fd);
	return true;
}

#define MAX_FDS 30

#define USB_MAX_IFACE_NUM 4
#define USB_MAX_EP_NUM 32
#define USB_MAX_FDS 6

struct usb_endpoint_index {
	struct usb_endpoint_descriptor desc;
	int handle;
};

struct usb_iface_index {
	struct usb_interface_descriptor* iface;
	uint8_t bInterfaceNumber;
	uint8_t bAlternateSetting;
	uint8_t bInterfaceClass;
	struct usb_endpoint_index eps[USB_MAX_EP_NUM];
	int eps_num;
};

struct usb_device_index {
	struct usb_device_descriptor* dev;
	struct usb_config_descriptor* config;
	uint8_t bDeviceClass;
	uint8_t bMaxPower;
	int config_length;
	struct usb_iface_index ifaces[USB_MAX_IFACE_NUM];
	int ifaces_num;
	int iface_cur;
};

struct usb_info {
	int fd;
	struct usb_device_index index;
};

static struct usb_info usb_devices[USB_MAX_FDS];

static struct usb_device_index* lookup_usb_index(int fd)
{
	for (int i = 0; i < USB_MAX_FDS; i++) {
		if (__atomic_load_n(&usb_devices[i].fd, __ATOMIC_ACQUIRE) == fd)
			return &usb_devices[i].index;
	}
	return NULL;
}

static int usb_devices_num;

static bool parse_usb_descriptor(const char* buffer, size_t length, struct usb_device_index* index)
{
	if (length < sizeof(*index->dev) + sizeof(*index->config))
		return false;
	memset(index, 0, sizeof(*index));
	index->dev = (struct usb_device_descriptor*)buffer;
	index->config = (struct usb_config_descriptor*)(buffer + sizeof(*index->dev));
	index->bDeviceClass = index->dev->bDeviceClass;
	index->bMaxPower = index->config->bMaxPower;
	index->config_length = length - sizeof(*index->dev);
	index->iface_cur = -1;
	size_t offset = 0;
	while (true) {
		if (offset + 1 >= length)
			break;
		uint8_t desc_length = buffer[offset];
		uint8_t desc_type = buffer[offset + 1];
		if (desc_length <= 2)
			break;
		if (offset + desc_length > length)
			break;
		if (desc_type == USB_DT_INTERFACE && index->ifaces_num < USB_MAX_IFACE_NUM) {
			struct usb_interface_descriptor* iface = (struct usb_interface_descriptor*)(buffer + offset);
			index->ifaces[index->ifaces_num].iface = iface;
			index->ifaces[index->ifaces_num].bInterfaceNumber = iface->bInterfaceNumber;
			index->ifaces[index->ifaces_num].bAlternateSetting = iface->bAlternateSetting;
			index->ifaces[index->ifaces_num].bInterfaceClass = iface->bInterfaceClass;
			index->ifaces_num++;
		}
		if (desc_type == USB_DT_ENDPOINT && index->ifaces_num > 0) {
			struct usb_iface_index* iface = &index->ifaces[index->ifaces_num - 1];
			if (iface->eps_num < USB_MAX_EP_NUM) {
				memcpy(&iface->eps[iface->eps_num].desc, buffer + offset, sizeof(iface->eps[iface->eps_num].desc));
				iface->eps_num++;
			}
		}
		offset += desc_length;
	}
	return true;
}

static struct usb_device_index* add_usb_index(int fd, const char* dev, size_t dev_len)
{
	int i = __atomic_fetch_add(&usb_devices_num, 1, __ATOMIC_RELAXED);
	if (i >= USB_MAX_FDS)
		return NULL;
	if (!parse_usb_descriptor(dev, dev_len, &usb_devices[i].index))
		return NULL;
	__atomic_store_n(&usb_devices[i].fd, fd, __ATOMIC_RELEASE);
	return &usb_devices[i].index;
}

struct vusb_connect_string_descriptor {
	uint32_t len;
	char* str;
} __attribute__((packed));

struct vusb_connect_descriptors {
	uint32_t qual_len;
	char* qual;
	uint32_t bos_len;
	char* bos;
	uint32_t strs_len;
	struct vusb_connect_string_descriptor strs[0];
} __attribute__((packed));

static const char default_string[] = {
    8, USB_DT_STRING,
    's', 0, 'y', 0, 'z', 0
};

static const char default_lang_id[] = {
    4, USB_DT_STRING,
    0x09, 0x04
};

static bool lookup_connect_response_in(int fd, const struct vusb_connect_descriptors* descs,
				       const struct usb_ctrlrequest* ctrl,
				       struct usb_qualifier_descriptor* qual,
				       char** response_data, uint32_t* response_length)
{
	struct usb_device_index* index = lookup_usb_index(fd);
	uint8_t str_idx;
	if (!index)
		return false;
	switch (ctrl->bRequestType & USB_TYPE_MASK) {
	case USB_TYPE_STANDARD:
		switch (ctrl->bRequest) {
		case USB_REQ_GET_DESCRIPTOR:
			switch (ctrl->wValue >> 8) {
			case USB_DT_DEVICE:
				*response_data = (char*)index->dev;
				*response_length = sizeof(*index->dev);
				return true;
			case USB_DT_CONFIG:
				*response_data = (char*)index->config;
				*response_length = index->config_length;
				return true;
			case USB_DT_STRING:
				str_idx = (uint8_t)ctrl->wValue;
				if (descs && str_idx < descs->strs_len) {
					*response_data = descs->strs[str_idx].str;
					*response_length = descs->strs[str_idx].len;
					return true;
				}
				if (str_idx == 0) {
					*response_data = (char*)&default_lang_id[0];
					*response_length = default_lang_id[0];
					return true;
				}
				*response_data = (char*)&default_string[0];
				*response_length = default_string[0];
				return true;
			case USB_DT_BOS:
				*response_data = descs->bos;
				*response_length = descs->bos_len;
				return true;
			case USB_DT_DEVICE_QUALIFIER:
				if (!descs->qual) {
					qual->bLength = sizeof(*qual);
					qual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;
					qual->bcdUSB = index->dev->bcdUSB;
					qual->bDeviceClass = index->dev->bDeviceClass;
					qual->bDeviceSubClass = index->dev->bDeviceSubClass;
					qual->bDeviceProtocol = index->dev->bDeviceProtocol;
					qual->bMaxPacketSize0 = index->dev->bMaxPacketSize0;
					qual->bNumConfigurations = index->dev->bNumConfigurations;
					qual->bRESERVED = 0;
					*response_data = (char*)qual;
					*response_length = sizeof(*qual);
					return true;
				}
				*response_data = descs->qual;
				*response_length = descs->qual_len;
				return true;
			default:
				break;
			}
			break;
		default:
			break;
		}
		break;
	default:
		break;
	}
	return false;
}

typedef bool (*lookup_connect_out_response_t)(int fd, const struct vusb_connect_descriptors* descs,
					      const struct usb_ctrlrequest* ctrl, bool* done);

static bool lookup_connect_response_out_generic(int fd, const struct vusb_connect_descriptors* descs,
						const struct usb_ctrlrequest* ctrl, bool* done)
{
	switch (ctrl->bRequestType & USB_TYPE_MASK) {
	case USB_TYPE_STANDARD:
		switch (ctrl->bRequest) {
		case USB_REQ_SET_CONFIGURATION:
			*done = true;
			return true;
		default:
			break;
		}
		break;
	}
	return false;
}

#define UDC_NAME_LENGTH_MAX 128

struct usb_raw_init {
	__u8 driver_name[UDC_NAME_LENGTH_MAX];
	__u8 device_name[UDC_NAME_LENGTH_MAX];
	__u8 speed;
};

enum usb_raw_event_type {
	USB_RAW_EVENT_INVALID = 0,
	USB_RAW_EVENT_CONNECT = 1,
	USB_RAW_EVENT_CONTROL = 2,
};

struct usb_raw_event {
	__u32 type;
	__u32 length;
	__u8 data[0];
};

struct usb_raw_ep_io {
	__u16 ep;
	__u16 flags;
	__u32 length;
	__u8 data[0];
};

#define USB_RAW_EPS_NUM_MAX 30
#define USB_RAW_EP_NAME_MAX 16
#define USB_RAW_EP_ADDR_ANY 0xff

struct usb_raw_ep_caps {
	__u32 type_control : 1;
	__u32 type_iso : 1;
	__u32 type_bulk : 1;
	__u32 type_int : 1;
	__u32 dir_in : 1;
	__u32 dir_out : 1;
};

struct usb_raw_ep_limits {
	__u16 maxpacket_limit;
	__u16 max_streams;
	__u32 reserved;
};

struct usb_raw_ep_info {
	__u8 name[USB_RAW_EP_NAME_MAX];
	__u32 addr;
	struct usb_raw_ep_caps caps;
	struct usb_raw_ep_limits limits;
};

struct usb_raw_eps_info {
	struct usb_raw_ep_info eps[USB_RAW_EPS_NUM_MAX];
};

#define USB_RAW_IOCTL_INIT _IOW('U', 0, struct usb_raw_init)
#define USB_RAW_IOCTL_RUN _IO('U', 1)
#define USB_RAW_IOCTL_EVENT_FETCH _IOR('U', 2, struct usb_raw_event)
#define USB_RAW_IOCTL_EP0_WRITE _IOW('U', 3, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP0_READ _IOWR('U', 4, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP_ENABLE _IOW('U', 5, struct usb_endpoint_descriptor)
#define USB_RAW_IOCTL_EP_DISABLE _IOW('U', 6, __u32)
#define USB_RAW_IOCTL_EP_WRITE _IOW('U', 7, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP_READ _IOWR('U', 8, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_CONFIGURE _IO('U', 9)
#define USB_RAW_IOCTL_VBUS_DRAW _IOW('U', 10, __u32)
#define USB_RAW_IOCTL_EPS_INFO _IOR('U', 11, struct usb_raw_eps_info)
#define USB_RAW_IOCTL_EP0_STALL _IO('U', 12)
#define USB_RAW_IOCTL_EP_SET_HALT _IOW('U', 13, __u32)
#define USB_RAW_IOCTL_EP_CLEAR_HALT _IOW('U', 14, __u32)
#define USB_RAW_IOCTL_EP_SET_WEDGE _IOW('U', 15, __u32)

static int usb_raw_open()
{
	return open("/dev/raw-gadget", O_RDWR);
}

static int usb_raw_init(int fd, uint32_t speed, const char* driver, const char* device)
{
	struct usb_raw_init arg;
	strncpy((char*)&arg.driver_name[0], driver, sizeof(arg.driver_name));
	strncpy((char*)&arg.device_name[0], device, sizeof(arg.device_name));
	arg.speed = speed;
	return ioctl(fd, USB_RAW_IOCTL_INIT, &arg);
}

static int usb_raw_run(int fd)
{
	return ioctl(fd, USB_RAW_IOCTL_RUN, 0);
}

static int usb_raw_configure(int fd)
{
	return ioctl(fd, USB_RAW_IOCTL_CONFIGURE, 0);
}

static int usb_raw_vbus_draw(int fd, uint32_t power)
{
	return ioctl(fd, USB_RAW_IOCTL_VBUS_DRAW, power);
}

static int usb_raw_ep0_write(int fd, struct usb_raw_ep_io* io)
{
	return ioctl(fd, USB_RAW_IOCTL_EP0_WRITE, io);
}

static int usb_raw_ep0_read(int fd, struct usb_raw_ep_io* io)
{
	return ioctl(fd, USB_RAW_IOCTL_EP0_READ, io);
}

static int usb_raw_event_fetch(int fd, struct usb_raw_event* event)
{
	return ioctl(fd, USB_RAW_IOCTL_EVENT_FETCH, event);
}

static int usb_raw_ep_enable(int fd, struct usb_endpoint_descriptor* desc)
{
	return ioctl(fd, USB_RAW_IOCTL_EP_ENABLE, desc);
}

static int usb_raw_ep_disable(int fd, int ep)
{
	return ioctl(fd, USB_RAW_IOCTL_EP_DISABLE, ep);
}

static int usb_raw_ep0_stall(int fd)
{
	return ioctl(fd, USB_RAW_IOCTL_EP0_STALL, 0);
}

#define USB_MAX_PACKET_SIZE 4096

struct usb_raw_control_event {
	struct usb_raw_event inner;
	struct usb_ctrlrequest ctrl;
	char data[USB_MAX_PACKET_SIZE];
};

struct usb_raw_ep_io_data {
	struct usb_raw_ep_io inner;
	char data[USB_MAX_PACKET_SIZE];
};

static void set_interface(int fd, int n)
{
	struct usb_device_index* index = lookup_usb_index(fd);
	if (!index)
		return;
	if (index->iface_cur >= 0 && index->iface_cur < index->ifaces_num) {
		for (int ep = 0; ep < index->ifaces[index->iface_cur].eps_num; ep++) {
			int rv = usb_raw_ep_disable(fd, index->ifaces[index->iface_cur].eps[ep].handle);
			if (rv < 0) {
			} else {
			}
		}
	}
	if (n >= 0 && n < index->ifaces_num) {
		for (int ep = 0; ep < index->ifaces[n].eps_num; ep++) {
			int rv = usb_raw_ep_enable(fd, &index->ifaces[n].eps[ep].desc);
			if (rv < 0) {
			} else {
				index->ifaces[n].eps[ep].handle = rv;
			}
		}
		index->iface_cur = n;
	}
}

static int configure_device(int fd)
{
	struct usb_device_index* index = lookup_usb_index(fd);
	if (!index)
		return -1;
	int rv = usb_raw_vbus_draw(fd, index->bMaxPower);
	if (rv < 0) {
		return rv;
	}
	rv = usb_raw_configure(fd);
	if (rv < 0) {
		return rv;
	}
	set_interface(fd, 0);
	return 0;
}

static volatile long syz_usb_connect_impl(uint64_t speed, uint64_t dev_len, const char* dev,
					  const struct vusb_connect_descriptors* descs,
					  lookup_connect_out_response_t lookup_connect_response_out)
{
	if (!dev) {
		return -1;
	}
	int fd = usb_raw_open();
	if (fd < 0) {
		return fd;
	}
	if (fd >= MAX_FDS) {
		close(fd);
		return -1;
	}
	struct usb_device_index* index = add_usb_index(fd, dev, dev_len);
	if (!index) {
		return -1;
	}
	char device[32];
	sprintf(&device[0], "dummy_udc.%llu", procid);
	int rv = usb_raw_init(fd, speed, "dummy_udc", &device[0]);
	if (rv < 0) {
		return rv;
	}
	rv = usb_raw_run(fd);
	if (rv < 0) {
		return rv;
	}
	bool done = false;
	while (!done) {
		struct usb_raw_control_event event;
		event.inner.type = 0;
		event.inner.length = sizeof(event.ctrl);
		rv = usb_raw_event_fetch(fd, (struct usb_raw_event*)&event);
		if (rv < 0) {
			return rv;
		}
		if (event.inner.type != USB_RAW_EVENT_CONTROL)
			continue;
		char* response_data = NULL;
		uint32_t response_length = 0;
		struct usb_qualifier_descriptor qual;
		if (event.ctrl.bRequestType & USB_DIR_IN) {
			if (!lookup_connect_response_in(fd, descs, &event.ctrl, &qual, &response_data, &response_length)) {
				usb_raw_ep0_stall(fd);
				continue;
			}
		} else {
			if (!lookup_connect_response_out(fd, descs, &event.ctrl, &done)) {
				usb_raw_ep0_stall(fd);
				continue;
			}
			response_data = NULL;
			response_length = event.ctrl.wLength;
		}
		if ((event.ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD &&
		    event.ctrl.bRequest == USB_REQ_SET_CONFIGURATION) {
			rv = configure_device(fd);
			if (rv < 0) {
				return rv;
			}
		}
		struct usb_raw_ep_io_data response;
		response.inner.ep = 0;
		response.inner.flags = 0;
		if (response_length > sizeof(response.data))
			response_length = 0;
		if (event.ctrl.wLength < response_length)
			response_length = event.ctrl.wLength;
		response.inner.length = response_length;
		if (response_data)
			memcpy(&response.data[0], response_data, response_length);
		else
			memset(&response.data[0], 0, response_length);
		if (event.ctrl.bRequestType & USB_DIR_IN) {
			rv = usb_raw_ep0_write(fd, (struct usb_raw_ep_io*)&response);
		} else {
			rv = usb_raw_ep0_read(fd, (struct usb_raw_ep_io*)&response);
		}
		if (rv < 0) {
			return rv;
		}
	}
	sleep_ms(200);
	return fd;
}

static volatile long syz_usb_connect(volatile long a0, volatile long a1, volatile long a2, volatile long a3)
{
	uint64_t speed = a0;
	uint64_t dev_len = a1;
	const char* dev = (const char*)a2;
	const struct vusb_connect_descriptors* descs = (const struct vusb_connect_descriptors*)a3;
	return syz_usb_connect_impl(speed, dev_len, dev, descs, &lookup_connect_response_out_generic);
}

static void kill_and_wait(int pid, int* status)
{
	kill(-pid, SIGKILL);
	kill(pid, SIGKILL);
	for (int i = 0; i < 100; i++) {
		if (waitpid(-1, status, WNOHANG | __WALL) == pid)
			return;
		usleep(1000);
	}
	DIR* dir = opendir("/sys/fs/fuse/connections");
	if (dir) {
		for (;;) {
			struct dirent* ent = readdir(dir);
			if (!ent)
				break;
			if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
				continue;
			char abort[300];
			snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort", ent->d_name);
			int fd = open(abort, O_WRONLY);
			if (fd == -1) {
				continue;
			}
			if (write(fd, abort, 1) < 0) {
			}
			close(fd);
		}
		closedir(dir);
	} else {
	}
	while (waitpid(-1, status, __WALL) != pid) {
	}
}

static void setup_test()
{
	prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
	setpgrp();
	write_file("/proc/self/oom_score_adj", "1000");
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
	int iter = 0;
	for (;; iter++) {
		int pid = fork();
		if (pid < 0)
	exit(1);
		if (pid == 0) {
			setup_test();
			execute_one();
			exit(0);
		}
		int status = 0;
		uint64_t start = current_time_ms();
		for (;;) {
			sleep_ms(10);
			if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
				break;
			if (current_time_ms() - start < 5000)
				continue;
			kill_and_wait(pid, &status);
			break;
		}
	}
}

void execute_one(void)
{
		if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {}
memcpy((void*)0x20001340, "\x12\x01\x00\x02\xbb\xa7\x78\x08\x24\x04\x30\xcf\x3f\x86\x01\x02\x03\x01\x09\x02\xcf\x0a\x04\x08\x7f\x00\x09\x09\x04\xcf\x06\x0b\x21\x85\x65\x06\x74\x23\xc9\x54\x20\x00\xbe\xe2\xee\xac\xa5\xd3\x3c\x6e\x00\x14\x91\xe1\x89\x15\x62\xc1\x48\x5a\x60\xc8\xb8\xdc\xab\xd0\x03\x91\xfc\x22\xfc\x18\x40\xbf\x6a\x69\x98\x59\x40\x41\xe6\xcb\xd6\xcc\xac\xed\x46\x7f\x17\x98\x4a\x77\xfd\x5f\xcc\xbd\x6a\xa4\xc3\x0f\x43\x69\xad\x60\x3e\x2a\x12\xdd\xda\x8c\x44\x91\xc0\xf2\x4a\x27\xe6\x70\x47\x10\x11\x7d\xe7\xa2\x0d\xa7\x18\x8f\xb8\x93\x42\x14\xe9\x06\xcd\x5b\x1b\x6c\x04\xf6\x84\xdf\x10\xcb\x00\x23\x71\xe3\xf8\xeb\xcd\x35\x09\x05\x08\x10\x08\x00\x06\x9c\x01\x07\x25\x01\x00\x06\x44\x0d\x07\x25\x01\x03\x04\x81\x00\x09\x05\x0d\x00\x08\x00\x06\x00\xb8\x09\x05\x09\x02\x00\x02\x38\x08\x7f\x07\x25\x01\x00\x02\x09\x00\x09\x05\x0b\x08\x08\x00\x40\x00\x40\x07\x25\x01\x81\x04\x08\x00\x80\x0d\xb8\xea\x92\xc1\x3c\xe6\xd7\x7e\xaa\x3b\xf7\xdb\x42\x5c\x50\x45\xd0\x6b\xd1\x80\x7b\x7d\xc2\x21\x20\x8e\x81\xa5\x2a\xac\x36\xea\xee\xa9\x85\x3a\xbf\x1f\xae\x2f\xb4\x11\x64\x5a\xcf\x23\x46\x45\x52\x36\x7f\xb6\x34\x18\xce\xe2\x47\x51\xdc\x38\x1d\x9a\x01\xa8\xe2\x59\x9c\xcf\x8c\xa4\x6e\xd3\x49\x46\x0b\x21\x86\x59\x10\x64\x06\xac\xcc\xe2\x2f\xcf\x02\xc7\xb7\x7d\xe3\xbd\xfa\x64\x28\xd0\xa9\xa3\x7b\xad\x2e\xa9\xdb\xa2\xec\x19\x37\x7d\x03\x83\xcb\x2b\x30\x1c\x18\xca\xbd\x0c\xa6\x47\x32\xbe\x8e\x2b\x02\x6f\x09\x05\x00\x04\x00\x04\x08\x02\xff\x09\x05\x08\x00\x00\x04\x04\xce\x40\x07\x25\x01\x00\x01\x08\x00\x09\x05\x05\x00\xbf\x03\x0d\x02\x08\x09\x05\x0b\x02\x40\x00\x04\x02\x05\x09\x05\x02\x10\x00\x02\x03\x0e\x03\x09\x05\x03\x08\x10\x00\x25\x80\xf8\x28\x06\xb1\x3e\xed\x52\x78\xf0\xb2\x9a\x3d\x4b\x3c\x07\xbd\x3b\x5d\xf4\x88\xfa\x88\x9a\xb4\xa1\x8f\x49\xe2\x77\x93\x84\x60\x44\xc1\x4a\xc2\xaa\x11\xaf\xbc\x6e\x09\x05\x01\x0c\x10\x00\x01\x02\x04\x09\x04\x92\x09\x08\xd8\xfd\xa8\x09\x0a\x24\x06\x00\x01\x0e\xe4\x39\x67\xba\x05\x24\x00\xfc\x00\x0d\x24\x0f\x01\x44\x00\x00\x00\x00\x00\xff\x07\x81\x06\x24\x1a\x00\x02\x22\x0a\x24\x01\x0a\x00\x01\x02\x01\x02\x07\x24\x08\x06\x0a\x00\x0c\x09\x05\x0f\x03\x20\x02\x9d\x06\x4e\x07\x25\x01\x81\x03\x06\x00\x09\x05\x02\x00\x58\x00\x00\x05\x19\xa5\x1c\x02\x2f\xb2\xea\x67\xca\x39\x7e\xfb\x89\x6f\xa0\xa7\x7a\xdb\x14\x3b\x57\x3a\x95\x64\x34\xb6\xe2\x69\xc1\xd5\x19\x70\xc7\x99\x38\x20\x88\xd6\x04\x47\x7c\x31\x8a\x90\x27\xed\xe0\x8b\x41\x39\x14\x56\x80\x84\xd7\x9f\x7b\x47\xf6\x55\xe2\x26\xc4\x9c\xaa\xb6\xe0\x74\xf3\xbc\xe7\xfc\xc5\xfd\x04\xa7\xa6\x85\x09\xe0\xd4\xd5\x82\x41\xbf\x6d\xd7\x7b\x9a\xa8\xda\xbc\xaf\x69\xa1\x40\x42\xe7\xd5\xaf\x25\x6e\x76\xa9\xb9\x5c\x74\xa7\x09\x0f\xb7\x84\xaf\x64\x3c\x76\xf9\x30\xe1\xf2\x24\xd2\xfc\x8e\x40\x5b\xe8\x5e\xda\xe3\xf8\x8f\xcb\x66\xe4\xb8\xcb\x64\xc8\x7b\x3a\x3e\xcb\x4b\x08\x4e\x33\x48\xb1\x59\x11\x97\x83\x0f\xab\x16\x1d\xdc\xd2\x45\x14\x6f\x09\xcd\x65\xf4\x09\x05\x0d\x00\x08\x00\x80\x02\xfe\x07\x25\x01\x01\x05\x04\x00\x09\x05\x03\x08\x40\x00\x00\x07\x06\x07\x25\x01\x02\x02\x00\x00\x97\x11\xc5\xf3\x11\xf7\xee\xfb\xcc\x14\x93\x89\x88\x20\xaf\xd4\xe9\xae\x21\xdf\x94\xcc\x54\x05\xee\xf1\x78\xe0\xa1\x3c\x74\x1e\xc6\xb6\x5d\x14\xf8\x62\x4d\xd9\xaf\xd1\xb9\x7b\xda\x01\x92\xcf\x52\x71\xaf\x8a\x9d\xf0\xf6\x83\x0b\x41\x9f\x84\x56\xdd\xd3\xba\x4e\xcb\xd1\x3b\xeb\x53\x49\xc3\xd2\xb6\x19\x4d\x31\x7a\x7b\x52\xc1\xf4\xef\x80\xee\x63\x5f\xd9\xa7\x55\xa0\xc6\xa7\x87\x85\xf2\xdc\xbb\x08\x6a\xcf\xbf\xf4\xfe\x85\xc3\x0f\x05\x47\x30\x4c\xe3\x83\x10\x85\xc5\x68\xe9\xcc\xf7\x90\x8c\x05\xe1\xb5\xbc\x26\xf8\x50\x6d\xc2\x90\x57\xf0\xa6\x58\x78\xb6\xa1\x6e\x75\x83\x1f\x9d\xfd\xfa\xbf\x11\xbd\x29\xd0\x09\x05\x0e\x02\x00\x00\x0f\x01\x02\x49\x22\x65\x4d\x83\x52\x07\x0e\x93\xbc\x2e\x68\xce\x2b\x9e\x6a\x9d\x13\x57\x5e\xbb\x90\x95\x63\xf4\x27\x12\xcb\xa0\x6e\xb2\x2d\x35\x0b\xbd\x8a\xe6\x03\xb3\x18\x23\x37\xc6\x5b\xf6\x14\x09\x79\x0c\xbe\x9b\x21\x87\x67\x47\xf6\x70\x18\x7a\xe8\x80\xd7\xfb\xab\x78\x17\x41\xeb\x6f\x3b\x2c\x50\xb6\x09\x05\x01\x02\x40\x00\x06\x04\x06\x09\x05\x0c\x10\xff\x03\x7e\x09\x23\x07\x25\x01\x01\x04\x2f\xd7\xa7\x04\x7d\xd5\x8a\x0b\x8c\x37\xd2\xc1\x73\xd1\x64\x9c\xc6\xff\x7d\x3f\x4c\x7b\x67\x2c\x80\x28\xab\x12\x08\x1f\x15\x0a\x6c\x47\x38\x64\x9a\x14\x60\xb2\x66\x6b\x79\x2a\xc6\x23\x06\xda\x93\xe6\x3f\x6b\x90\x39\xf3\xaf\xa7\x4c\x85\x63\x33\xd7\x84\x5e\x2e\x14\x20\xe7\x3f\x48\x39\x13\x94\x5f\xe1\xcf\x2e\x4c\x4f\xa8\xe2\x7d\xf2\x24\x2f\x10\xd5\xb2\x8a\x20\x80\xe1\x48\x6a\x7c\x1a\x08\x4b\xc7\xba\x69\xd1\x82\xcc\x22\xc3\x83\x0b\xd0\xa2\xc0\x72\x1b\x1a\xd4\xb7\x63\x87\x47\xa2\x41\x9a\x91\x1a\xd0\xf5\xf5\x7d\xdb\xca\xff\xe1\x6f\x6e\x4c\x4e\x21\x17\x39\x8d\xe9\x8b\x5f\xa9\xf7\x82\x15\xaf\x45\x92\x36\x0c\xb1\x50\x49\x8b\x1a\x33\x2a\x54\x65\x11\x3a\x63\xc0\x96\x79\x89\x38\x09\x05\x00\x01\x00\x02\x90\x04\x01\x09\x04\xaf\x0b\x06\x13\xad\xc1\x0c\x08\x24\x06\x00\x00\xe5\x50\x37\x05\x24\x00\x08\x00\x0d\x24\x0f\x01\x07\x00\x00\x00\x9b\x00\x7f\x00\xfa\x05\x24\x15\x09\x00\x11\x24\x13\x04\x50\xe0\x8f\x4f\x8e\x06\xe6\x8d\xca\xa2\x13\xe4\x80\x81\x24\x13\x00\x5d\xfc\x65\x60\xd3\xf1\x50\xf6\xc0\x91\xfc\x37\x51\x2d\xae\xe3\xe1\xe7\xcb\xeb\xbb\x12\x86\xc9\xf7\x46\x19\x12\xe5\xd9\xba\x56\x2e\xd2\x78\x3f\xee\xdf\xee\x2d\xee\x08\x1e\x6d\x03\x58\x3f\x5b\xc4\xab\xc5\x53\x3f\xd1\x15\x11\xcb\x49\xea\xb5\xbb\x16\xb6\x67\x46\x46\x78\x31\xb6\x2c\x0c\x72\xf9\xf2\x1f\x33\x1f\x73\xf0\x41\xa5\xe3\x21\x08\xca\x61\xd1\x30\x44\xea\x9f\xd3\x97\x93\xeb\x4d\xe8\x1e\xff\xfc\xee\xe1\x22\xc8\x13\xe4\xda\xa5\xd9\x48\x4f\xbb\x49\x3c\x76\x25\x0d\xbe\x78\x5f\xa4\xb8\xf6\xa2\x05\x08\x24\x07\x03\x81\x00\x06\x00\x05\x24\x01\x00\x07\x09\x05\x06\x00\x00\x02\x00\xfe\x01\x09\x05\x0e\x1f\x10\x00\x56\x06\x06\x09\x05\x06\x10\x20\x00\x01\x10\x20\xb6\x23\xaa\xa4\x00\xd7\xef\x39\x1c\xc4\x22\x6f\xaa\x13\x16\x0b\x72\xf5\x6f\x11\x35\x92\x57\xec\x8d\x4e\x56\x7c\xe3\xcc\x97\xfd\x2c\x4e\x9f\xae\x36\xe0\x1f\x19\x3f\x35\x1a\xaf\xf2\x34\xce\x86\xf3\xf8\x0e\xe4\x77\x2e\x85\x1e\x96\xb7\xdb\x98\x15\x8f\x0b\x96\x66\x1d\xe8\x96\xdf\x13\x58\x4f\x97\x47\xc0\x98\x54\xab\x5e\x8d\x33\x93\xd1\xda\x5c\xbb\xd0\xa9\x44\x0f\xa5\xf5\xb8\x70\xaf\x7b\xd8\xc7\x47\x3b\x38\xd3\x4c\x51\xd7\x81\x4c\x10\x37\xe9\xfa\x23\x23\xdf\xec\xdc\xaf\x9d\x19\x6b\xc2\x74\xb6\xa0\xf5\x52\xc9\xe8\x07\x77\xb7\x82\xa4\x10\xe5\xa1\xc1\x1b\xf2\x6a\xde\xea\x4b\x18\x76\x82\xa1\x10\x9c\xc8\xd4\x66\xe9\x49\xe5\x6c\xb7\x15\xfc\x2a\x63\x65\xdb\xcc\x0d\xee\x71\xa7\xaa\x46\xfa\xdc\x16\x2f\xd4\xf3\xa6\x34\xe3\x73\xb9\xc9\x02\x0d\xf6\x2a\xd3\x2f\xa3\x80\x87\xdd\x22\x1c\xf3\xfb\xdb\x74\xf9\xd3\x2f\x43\x90\xb0\x42\xe5\xd6\xed\xd6\xf9\x4c\xbb\xe4\xd1\xb4\x7c\xa0\xd1\x64\x87\x6b\xc2\x77\x89\x28\xf9\x8e\x7a\xb2\xc1\x80\x64\x5c\x98\x04\xff\xb2\x12\xab\xae\x6d\x34\x5a\x6e\x01\xc3\x2b\x97\x14\x58\x64\xe1\xb3\xe4\xaf\x98\x22\xc5\x6f\x3a\xa4\xdb\x07\x2a\x36\xe9\xc4\x8f\x91\xe1\xf7\x65\x4c\x11\xfe\x99\x1c\x82\xe4\xf1\x2c\x38\x99\x7b\x3c\x15\x15\x6d\x16\xb7\xa0\x70\x90\x87\xb3\x93\xd4\x25\xa6\xb8\x6b\xfa\xbf\x27\x88\xd7\x15\x65\x3f\x3f\xe1\x42\x15\x5e\xd5\x82\xfe\xf4\x72\x41\xd1\x99\x03\x17\xa7\x15\x4f\x0c\x90\x57\x24\x81\x09\x6b\xf4\xdc\x79\xb9\x23\x88\x97\xb6\x58\xe5\xa7\x96\xde\x61\x42\xb5\xbc\x43\x86\xbc\x64\x57\x96\x6e\xec\xff\x89\xc1\x60\xb2\x81\x9d\x6a\x0a\x4b\x8c\x3f\xb7\x70\x79\xff\x40\x07\x68\x26\x7b\x1f\x47\xa1\x5b\x62\x6c\xaa\x94\x8a\xc7\x6c\x3e\x3c\x7e\xa3\x1d\x2e\x1f\xc9\xeb\x89\x17\x57\xed\xa8\x65\x64\xd1\x0a\x7f\x37\xea\x73\xe2\xb6\x7f\xea\xdd\x30\x4a\x1b\x16\xb0\xa2\xb5\xd0\xc2\xf7\x51\x28\xb5\x2b\xed\x6e\x95\x8c\x69\xc3\xf0\xfa\x09\x05\x02\x02\xff\x03\x07\x04\x7f\x09\x05\x00\x00\x10\x00\xb6\x7f\xf7\x53\x05\xa2\x42\xd9\x9a\xe9\xf1\x9d\x89\x1e\x56\x0b\x10\xd7\x0d\xef\x33\x17\x47\x7b\xb1\x58\xf3\x4b\x7e\x22\x3d\xa7\x89\x24\x6c\xa1\x71\x65\x9b\x24\xa6\x73\x35\x56\xf8\x38\xe9\x3a\x87\x88\xcb\x2d\x07\xcf\x29\x11\xca\xc1\xa0\x31\x83\x77\x35\x08\x74\xe1\x53\xcf\x59\xbc\xd5\x53\xa3\xcb\x30\xdd\x69\xa7\x41\xd3\xb9\x1a\xab\xed\x5f\x5c\x07\x25\x01\x01\x05\x76\x00\x09\x05\x01\x00\x10\x00\x08\x09\x07\x09\x04\x2c\x0a\x07\xff\x80\x91\x00\x09\x05\x07\x10\x08\x00\xe7\x05\x4d\xbf\x11\x29\x2f\xec\xd6\x3f\xd3\x86\x60\x1d\x8e\x98\x09\x33\x89\xfb\x01\x7c\xc5\xf0\xe1\x9c\xa0\xac\xea\x1e\x2c\x58\xb9\xcb\x33\x3c\xd7\x61\x02\xee\x9c\x25\x51\xc4\x95\xd3\x7c\x11\xe8\x4e\x58\x44\x69\x80\xf6\xdd\xe6\xc0\x6c\xea\x51\xc1\xee\xb2\xb9\x8e\x25\x50\x82\xd2\x1d\xa9\x52\x0a\x0f\x3b\x13\xa5\xbc\x24\xe6\xbb\x08\xb7\x8b\xf5\xe9\xbf\x70\x6c\xdd\x10\x87\xf8\x42\x78\x10\xcb\x5c\x0c\x2e\x73\xb0\xd4\xaf\xb1\x51\xd5\x02\x3b\xaa\x3d\x92\xb3\x9e\x24\x9d\xce\x4c\xee\x27\xf2\x1c\x11\xd6\xcd\xb5\x1c\xe3\x56\x3c\x88\xfb\xa0\xbf\xf1\x3b\xca\xec\x65\xdb\x58\xed\x53\x98\xca\x47\xb3\x39\xc3\x50\x1b\xe4\x45\xf7\x9a\x65\x0c\xe6\x53\x82\x6c\x68\x83\xc0\xd7\x25\x9e\xcb\x2d\xd3\xd9\xe8\x11\x7f\x8c\xa0\x44\x0b\xbf\x1f\x5d\xd3\x1d\x34\xa3\x58\x3c\x86\xc6\xf9\xc9\x28\xb0\x0f\x0f\xdc\x33\xf7\xa8\x89\x94\xc8\x63\x88\xe5\x5e\xcb\xd0\x09\x05\x07\x08\x40\x00\x07\x04\x14\x07\x25\x01\x03\x07\x05\x00\x07\x25\x01\x03\x02\x00\x01\x09\x05\x05\x02\x00\x04\x09\x00\x01\x09\x05\x06\x00\x08\x00\x03\x79\x03\x07\x25\x01\x80\x05\xff\x07\xf9\x10\x4b\xa7\x59\x35\x30\x21\x7d\x3c\x49\x9b\x6b\x76\xf0\xc6\x37\x7e\x59\xdf\xc2\xa2\x7d\x26\xf7\xc4\x89\x06\xe5\x33\xa5\x6b\x05\xa8\xbc\x5b\x0c\x5d\x49\x61\xe1\x67\xbe\x9a\x63\xdc\x4e\x61\xe3\x95\xf1\xb2\x3a\xe0\xe2\xc6\xf8\xfd\x36\xa9\x3a\x3e\xf6\xc5\x45\x03\x6d\xb2\x74\xaf\xbc\x22\x38\xe4\xb0\xf5\x01\xb2\xa4\xe7\xbf\xbd\x17\x13\xa8\x51\x40\x72\x4b\xe2\x60\xf3\x67\x6a\x2e\xc4\xd5\xc5\xe3\xc6\x4c\x0d\x67\x83\x03\x64\xbc\xc3\xd5\x91\x64\xf1\x74\x53\xa7\xff\xfd\x54\xfb\xd0\x4b\xfd\xee\x63\x79\xfd\x2b\x51\x4e\xc3\xaa\x36\x3e\xa2\x97\x42\x6d\x02\xbf\x70\x19\xfa\xda\x86\x27\x6a\x3c\x2a\x4f\x46\x60\xdc\xec\x59\xe1\x21\x66\xc9\x4b\xaf\x3c\x8b\x00\x41\x59\xa3\xa1\x38\x99\x4e\xd2\xd1\xe5\x8a\x12\xcd\x06\x94\x43\x39\x4d\x49\x5c\xfb\x80\xb0\xd0\xc5\x32\x7d\xa0\xd2\x24\x26\xb7\xd1\x4f\x16\xe3\xc3\x09\x69\xa7\xaf\xb3\x7b\x07\x0e\x76\x93\x09\x96\x68\x93\xc3\x18\xbb\x0a\x65\xa4\xaf\x04\x4d\x4e\x3b\x3a\x7d\xee\xdf\xf0\x69\x82\x5c\xe8\x9c\x32\xe4\x02\x9d\xf5\x3a\xcb\xcd\x6a\x4b\xd9\xa7\x98\xee\x09\x05\x09\xaa\x00\x04\x07\x00\x08\x66\x22\x54\xc4\x49\x0a\xa1\xff\x4f\xbd\xa9\x63\xea\x10\x48\x86\x78\xb9\x9f\xc2\xcb\xbb\x87\x7a\xda\x04\x5e\x67\x59\x9c\xf5\x0c\x7a\xbe\x4a\x97\x57\x18\x6e\x8b\xdb\x72\xaa\x4d\xbf\xd7\x80\xf5\x79\x22\x4a\x09\x52\xd1\x73\x76\x1d\x86\x24\x61\x0d\xf7\x3a\x1f\x5b\x33\x93\x66\x43\x0c\x5d\x8b\x64\x01\xd0\x43\x5c\x83\x22\xaf\x15\x10\x4b\xc1\x6a\x4c\xd0\x65\xa3\xb7\x87\xd7\x53\xe9\xde\xbd\xa9\x16\x6d\x5b\xab\xa4\xb0\x0f\xb0\x0a\xd5\xb7\xfc\x69\x94\xd4\x0f\x9a\xd0\xd5\x09\xd0\x6b\x1b\x56\x14\x3e\xfd\xba\x3e\xe5\x45\x47\xc7\x0f\x48\x83\xea\xb9\x19\x73\x1f\xda\xea\x8f\x79\x6a\x1f\xcc\x80\x14\x70\xf3\x6c\x7e\x6b\x90\xf6\x5c\x66\xd3\x8f\x79\x31\x3b\x13\x2f\xdf\xa0\xe8\x52\xc5\x25\xfb\xad\xed\x9b\xb3\x64\x60\x14\xbd\xe7\x8c\xe4\x08\x90\x5a\x74\x34\xad\x78\xc0\xb1\x2b\x87\xf0\xc1\x50\xb0\x2b\x68\xce\x95\x43\x2d\x13\xa5\xda\xe6\xbd\x53\x86\xa6\x33\x2f\x3f\xc5\xa3\xd9\x5f\xc8\x54\xfc\xf5\x39\xe7\x16\xdb\x98\xd5\xbe\x49\x65\x14\x41\xda\xd2\x39\xc1\x1d\x08\x5f\x0e\x5b\xf2\xce\x1e\xd4\x6c\xfe\x3d\x4c\xbf\x96\x17\x84\x92\x52\x00\x6c\xe6\x4a\xc7\xaf\xaa\x95\x9b\x3c\xee\xd2\x7f\x6a\xbf\x8c\xa3\xc1\xe5\x0e\x5b\xed\x11\xe7\x26\x88\x5f\xec\x5c\xdc\x8c\xd8\x21\xd7\x32\x43\xf4\x09\x05\x00\x00\x20\x00\x06\x04\x07\x09\x05\x07\x00\x00\x02\x95\x0f\x02\x07\x25\x01\x83\x05\x09\x00", 2799);
syz_usb_connect(/*speed=*/0, /*dev_len=*/0xae1, /*dev=*/0x20001340, /*conn_descs=*/0);

}
int main(void)
{
		syscall(__NR_mmap, /*addr=*/0x1ffff000ul, /*len=*/0x1000ul, /*prot=*/0ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
	syscall(__NR_mmap, /*addr=*/0x20000000ul, /*len=*/0x1000000ul, /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/7ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
	syscall(__NR_mmap, /*addr=*/0x21000000ul, /*len=*/0x1000ul, /*prot=*/0ul, /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/0x32ul, /*fd=*/-1, /*offset=*/0ul);
	const char* reason;
	(void)reason;
			loop();
	return 0;
}
